#!/usr/bin/env ruby
require 'httparty'
require 'paint'
require 'thor'
require 'yaml'

begin
  config = YAML.load_file File.expand_path('~/.lard.yml')
rescue
  STDERR.puts 'Unable to find your .lard.yml!'
  STDERR.puts '  Please double-check this file:'
  STDERR.puts '    ~/.lard.yml'
  STDERR.puts '  And make sure it has your auth token:'
  STDERR.puts '    token: yourhashgoeshere'
  exit 1
end

begin
  token = config['token']
rescue
  STDERR.puts 'No token in ~/.lard.yml!'
  exit 1
end

$options = {
  headers: {
    'Authorization' => "Token #{token}"
  }
}
$folders = []

module LardHTTP
  def get(endpoint, params = nil)
    query = { query: params }
    opts = $options.merge query
    res = self.class.get "#{prefix}#{endpoint}", opts
    parse_response res
  end

  def post(endpoint, args = {})
    opts = { body: args.to_json, headers: {"Content-Type" => "application/json"} }
    opts[:headers].merge! $options[:headers]
    res = self.class.post "#{prefix}#{endpoint}", opts
    parse_response res
  end

  def parse_response(res)
    JSON.parse res.body, symbolize_names: true
  end

  def raw_get(url)
    JSON.parse self.class.get(url, $options).body, symbolize_names: true
  end

  def prefix
    'https://larder.io/api/1/@me/'
  end
 
  def get_folder_by_name(name)
    fetch_folders unless $folders.length > 0
    $folders.find do |folder|
      folder[:name] == name
    end
  end

  def print_folder_name(folder)
    print Paint[folder[:name], folder[:color]]
    puts ":\t#{folder[:links]} links"
  end

  def fetch_tags
    res = get 'tags', { limit: 100 }
    tags = res[:results] || []

    while res[:next] != nil
      res = raw_get res[:next]
      tags.push *res[:results]
    end

    tags
  end

  def fetch_bookmarks(folder_id)
    res = get "folders/#{folder_id}", { limit: 100 }
    bookmarks = res[:results] || []

    while res[:next] != nil
      res = raw_get res[:next]
      bookmarks.push *res[:results]
    end

    bookmarks
  end

  def fetch_folders
    res = get 'folders', { limit: 100 }
    $folders = res[:results]

    while res[:next] != nil
      res = raw_get res[:next]
      $folders.push *res[:results]
    end

    # TODO: Cache these folders
  end
  
  def print_bookmark(bookmark)
    puts Paint["#{bookmark[:title]}", :bright]
    puts "  #{bookmark[:description]}" if bookmark[:description]
    puts "  #{bookmark[:url]}"
      
    unless bookmark[:tags].empty?
      print "  "
      bookmark[:tags].each do |tag|
        print Paint["##{tag[:name]}", tag[:color]]
        print " "
      end
      puts " "
    end
  end

  def print_tag(tag)
    puts Paint["##{tag[:name]}", tag[:color]]
  end
end

class Bookmark < Thor
  include LardHTTP
  include HTTParty
  maintain_method_across_redirects

  desc 'new <FOLDER> <TITLE> <LINK> [tags...]', 'Creates a new bookmark'
  option :description, :aliases => :d
  def new(folder, title, link, *tags)
    f = get_folder_by_name folder
    raise "No such folder" unless f
    parent = f[:id]
    
    res = post 'links/add', {
      "title" => title,
      "url" => link,
      "parent" => parent,
      "description" => options[:description],
      "tags" => tags
    }
    unless res[:error]
      print_bookmark res
    else
      # TODO: Test this
      raise "Unable to add bookmark"
    end
  end

  # Note that this uses the same endpoint as 'new'
  # simply for the purpose of looking up bookmarks
  # by the link and not proprietary ID
  #desc 'edit <LINK> [tags...]', 'Edits an existing bookmark'
  #option :title, :aliases => :t
  #option :folder, :aliases => :f
  #option :description, :aliases => :d
  #def edit(link, *tags)
  #  f = get_folder_by_name options[:folder]
  #  raise "No such folder" unless f
  #  parent = f[:id]

  #  res = post 'links/add', {
  #    "title" => options[:title],
  #    "url" => link,
  #    "parent" => parent,
  #    "description" => options[:description],
  #    "tags" => tags
  #  }
  #  unless res[:error]
  #    print_bookmark res
  #  else
  #    # TODO: Test this
  #    raise "Unable to add bookmark"
  #  end
  #end
end

class Lard < Thor
  include LardHTTP
  include HTTParty
  maintain_method_across_redirects

  desc "bookmark", "[Interface] manage individual bookmarks"
  subcommand "bookmark", Bookmark

  desc 'user', 'Prints information about the logged-in user'
  def user
    puts get('user')
  end

  desc 'folders', 'Lists all bookmark folders'
  def folders
    if $folders == []
      fetch_folders
    end

    $folders.each do |folder|
      print_folder_name folder
    end
  end

  desc 'folder <NAME>', 'Lists all bookmarks in a given folder'
  def folder(name)
    folder = get_folder_by_name name
    raise "No such folder" unless folder

    print_folder_name folder

    bookmarks = fetch_bookmarks folder[:id]
    bookmarks.each do |bookmark|
      print_bookmark bookmark
    end
  end

  desc 'tags', 'Lists all tags'
  def tags
    tags = fetch_tags
    tags.each do |tag|
      print_tag tag
    end
  end

  desc 'search', 'Search for bookmarks'
  def search(*args)
    query = args.join ' '
    res = get 'search', { q: query }
    raise "No results for query #{query}" unless res[:results].length > 0
    bookmarks = res[:results]
    bookmarks.each do |b|
      print_bookmark b
    end
  end
end

Lard.start(ARGV)
